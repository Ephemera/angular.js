@ngdoc overview
@name FAQ
@description

#FAQ

## 질문
## Questions

### 왜 이 프로젝트는 "AngularJS"라고 불리는겁니까? 왜 네임스페이스(namespace)는 "ng"라고 불리나요?

HTML는 Angular(모난) 괄호를 가지고 있고, "ng"발음이 "Angular"와 비슷하기 때문입니다.


### AngularJS는 라이브러리 인가요? 아니면 프레임웍? 플러그인? 아니면 브라우저 익스텐션(browser extension)인가요?

일반적인 프레임웍보다 좀 더 많이 가볍기 때문에, 라이브러리라고 많이들 혼란스러워 하지만, AngularJS는 프레임웍의 정의와 가장 잘 들어맞는다고 하겠습니다.

AngularJS는 100% 자바스크립트이며, 100% 클라이언트 사이드입니다. 또한, 데스크탑과 모바일 브라우저에 모두 호환가능합니다.
따라서, AngularJS는 명확하게 플러그인 또는 다른 어떤 네이티브(native) 브라우저 익스텐션도 아닙니다.


### AngularJS는 템플릿을 만드는 시스템인가요?

최상의 레벨(level)에서는, Angular가 단지 또 다른 하나의 템플릿 시스템으로 보이기도 합니다. 하지만, Angular템플릿 시스템이 다른지에 대한 중요한 이유 한
가지가 있습니다. 이는 어플리케이션 개발(application development)에 매우 적합하다는 것입니다: : 양방향 데이터 바인딩(bidirectional data binding).
템플릿은 브라우저에서 컴파일 됩니다. 그리고, 컴파일 과정은 라이브뷰(live view)를 만들어냅니다. 당신에게, 개발자로서 주는 의미는, 당신이 다른 템플릿
 시스템에서와 같이 뷰(vioew)와 모델(model), 모델과 뷰를 연속적으로 동일하게 맞추기 위해서 코딩을 할 필요가 없다는 것입니다.


### AngularJS에서의 보안취약점(security holes)에 대해서 걱정해야 하나요?

다른 어떤 기술들과 같이, AngularJS는 공격에 대해서 완벽히 방어되지 않습니다. 그러나, Angular는 HTML 인젝션 공격(injection attacks)과 크로스사이트
스크립트(cross-site scripting)를 포함한 기본적인 보안취약으로부터 방어할 수 있는 내장된 보안 시스템을 제공합니다. AngularJS는 모든 문자열에 대해서
왕복탈출(round-trip escaping)을 하고, 심지어 서버사이드 통신(communication)을 위해서 XSRF방어를 제공합니다.
Like any other technology, AngularJS is not impervious to attack. Angular does, however, provide
built-in protection from basic security holes including cross-site scripting and HTML injection
attacks. AngularJS does round-trip escaping on all strings for you and even offers XSRF protection
for server-side communication.

AngularJS는 Content Security Policy(CSP), HTTPS (SSL/TLS) 그리고 서버사이드 입증, 또한 공격가능한 벡터(vectors)를 상당 수 줄여 줄 수 있는
 인증과 같은 다른 보안 방법들과 호환이 가능하도록 디자인 되었습니다. 그리고 그 것들의 사용에 대해 강력히 추천하는 바입니다.
AngularJS was designed to be compatible with other security measures like Content Security Policy
(CSP), HTTPS (SSL/TLS) and server-side authentication and authorization that greatly reduce the
possible attack vectors and we highly recommended their use.


### 소스, 빌드를 다운 받을 수 있을까요? 그리고 AngularJS 환경을 로컬에서 호스트 할 수 있을까요?
### Can I download the source, build, and host the AngularJS environment locally?

네. {@link downloading}에서 지시서를 확인해보십시오.
Yes. See instructions in {@link downloading}.



### 어떤 브라우저들이 Angular작업이 가능한가요?
### What browsers does Angular work with?

저희는 Safari, Chrome, Firefox, Opera,IE8, IE9 그리고 모바일 브라우져(Android, Chrome Mobile, iOS Safari)와 같은 브라우저를 상대로
광범위한 적합 테스트(test suite)를 실행했습니다..
We run our extensive test suite against the following browsers: Safari, Chrome, Firefox, Opera,
IE8, IE9 and mobile browsers (Android, Chrome Mobile, iOS Safari).


### Angular성능은 얼마나 되나요?
### What's Angular's performance like?

초기시작(startup)시간은 네트워크 접속상태, 캐쉬(cashe)상태, 사용하는 브라우저, 사용가능한 하드웨어에 따라 상당히 달라집니다. 그러나, 일반적으로
 붓스트랩(bootstrap)시간은 십여 밀리세컨(milliseconds) 또는 백여 밀리세컨으로 측정됩니다.
The startup time heavily depends on your network connection, state of the cache, browser used and
available hardware, but typically we measure bootstrap time in tens or hundreds of milliseconds.

실시간(runtime) 성능은 백엔드(backend)(백엔드로부터 데이터를 가져와야하는 앱의 경우)의 속도와 마찬가지로, 페이지에 사용한 바인딩(bindings)의 숫자와
복잡도에 상당히 영향을 받아 다양해 질 것 입니다. 우리는 예증을 위해서, 대체적으로 백여개에서 천여개의 액티브 바인딩(active bindings)를 사용한 짤막한 앱을
빌드합니다.
The runtime performance will vary depending on the number and complexity of bindings on the page
as well as the speed of your backend (for apps that fetch data from the backend). Just for an
illustration we typically build snappy apps with hundreds or thousands of active bindings.

### 추가해야할 angular.js파일이 얼마나 큰가요?
### How big is the angular.js file that I need to include?

압축되고, 최소화된 파일 사이즈는 29KB 미만입니다.
The size of the file is < 29KB compressed and minified.


### Angular와 함께 오픈소스 Closuer Library를 사용할 수 있나요?
### Can I use the open-source Closure Library with Angular?

네, {@link http://code.google.com/closure/library Closure Library}에서 Angular 위젯(widgets)를 사용하실 수 있습니다.
Yes, you can use widgets from the {@link http://code.google.com/closure/library Closure Library}
in Angular.

### Angular가 jQuery라이브러리를 사용하나요?
### Does Angular use the jQuery library?

네. 어플리케이션이 붓스트랩할 때 앱 안에 라이브러리가 존재한다면 Angular는 {@link http://jquery.com/ jQuery}를 사용할 수 있습니다.
Yes, Angular can use {@link http://jquery.com/ jQuery} if it's present in your app when the
application is being bootstrapped. If jQuery is not present in your script path, Angular falls back
to its own implementation of the subset of jQuery that we call {@link api/angular.element  jQLite}.


### Angular에서의 테스트가능성은 어떤가요?
### What is testability like in Angular?

기초단계부터 테스트가능하도록 디자인 되어있고, 매우 테스트 가능합니다. 매우 강력하게 독립적인 모의테스트(서버사이드 통신)를 제공하는 통합독립주입 프레임웍
(Integrated dependency injection framework)이 존재 합니다. 제세한 사항은 {@link api/ng service}를 참조하십시오.
Very testable and designed this way from ground up. It has an integrated dependency injection
framework, provides mocks for many heavy dependencies (server-side communication). See
{@link api/ng service} for details.


### 어떻게하면 Angular에 대해서 조금 더 배울 수 있을까요?
### How can I learn more about Angular?

July 17, 2012 talk을 시청하십시오.
"{@link http://www.youtube.com/watch?v=1CpiB3Wk25U AngularJS Intro + Dependency Injection}".
Watch the July 17, 2012 talk
"{@link http://www.youtube.com/watch?v=1CpiB3Wk25U AngularJS Intro + Dependency Injection}".


### Angular는 어떤 라이센스입니까?
### How is Angular licensed?

MIT 라이센스 입니다.
The MIT License.

### Angular로고를 다운받고 사용할 수 있습니까?
### Can I download and use the Angular logo artwork?

네! "{@link https://github.com/angular/angular.js/tree/master/images/logo angular.js/images/logo}"아래, 저희 github
 레포지토리에서 디자인 파일을 찾으실 수 있습니다.
 그 로고 디자인은 "{@link http://creativecommons.org/licenses/by-sa/3.0/Creative Commons Attribution-ShareAlike 3.0 Unported License}"
 라이센스 아래 제공됩니다. 만약 다른 사용처를 염두하신다면, 저희에게 연락주십시오.
Yes! You can find design files in our github repository, under "{@link https://github.com/angular/angular.js/tree/master/images/logo 
angular.js/images/logo}"
The logo design is licensed under a "{@link http://creativecommons.org/licenses/by-sa/3.0/ 
Creative Commons Attribution-ShareAlike 3.0 Unported License}". If you have some other use in mind, contact us.

### 어떻게 AngularJS 사은품을 구할 수 있을까요?
### How can I get some AngularJS schwag?

저희가 참가하는 행사에는 종종 적은 양의 티셔츠와 스키터를 가지고 갑니다. 당신이 주문을 한다면, 저희 사은품 담당자는 현재 가지고 있는 템플렛을 사용하는 조건으로
 당신을 위해 추가 생산작업을 기쁘게 임할 것입니다. 제작자들은 주문디자인을 파일로 가지고 있을 경우, 별도의 셋업 비용을 받지 않고 당신이 원하는 어떤 수량만큼
  생산할 수 있습니다.
We often bring a few t-shirts and stickers to events where we're presenting. If you want to order your own, the folks who
make our schwag will be happy to do a custom run for you, based on our existing template. By using the design they have on file,
they'll waive the setup costs, and you can order any quantity you need.

**스티커**
**Stickers**

tom@stickergiant.com로 이메일을 통하여 Tom Witting(또는 다른 영업부 직원)에게 연락하세요, 그리고 job #42711에 있는 것들과 같은 AngularJS
스키터를 주문하고 싶다고 말씀하세요.
Contact Tom Witting (or anyone in sales) via email at tom@stickergiant.com, and tell him you want to order some AngularJS
stickers just like the ones in job #42711. You'll have to give them your own info for billing and shipping. 

그 디자인이 똑같이 존재하는 한 {@link http://www.stickergiant.com StickerGiant}에서 재 주문 할인을 드릴 겁니다.
As long as the design stays exactly the same, {@link http://www.stickergiant.com StickerGiant} will give you a reorder discount.

**티셔츠**
**T-shirts**
{@link http://www.customink.com www.customink.com}를 통해서 영업부에 연락하세요 그리고 지난번 주문 번호 #2106371와 같이 "angularjs"이라
쓰인 디자인의 티셔츠를 원한다고 말씀하세요. 영수증발행과 배송을 위해 그들에게 당신의 정보를 전달하셔야 할 것 입니다.
Contact sales at {@link http://www.customink.com www.customink.com} and tell them you want some shirts with design name "angularjs",
just like past order #2106371. You'll have to give them your own info for billing and shipping.

그 디자인이 똑같이 존재하는 한, CustomInk에서는 초기 셋팅 비용을 청구하지 않을 것이고, 재 주문 할인도 드릴 것 입니다.
As long as the design stays exactly the same, CustomInk won't charge for any set up fees, and they'll give you a reorder discount.

## 일반적인 함정
## Common Pitfalls

 Angular 지원채널(Freenode에서의 #angularjs)은 Angular 신규 사용자들이 반복해서 빠지고 있는 많은 함정을 알고 있습니다.
 이 문서는 신규 사용자들이 어려움을 겪지 않도록 하는데 목적을 두고 있습니다.
The Angular support channel (#angularjs on Freenode) sees a number of recurring pitfalls that new users of Angular fall into.
This document aims to point them out before you discover them the hard way.

### DOM 조작
### DOM Manipulation

jQuery를 컨트롤러안의 DOM을 수정하는데 사용하는 것을 멈추십시오. 정말로,
Angular는 엘리먼트(elements) 추가, 삭제, 컨텐츠(contents) 검색, 보이기 & 숨기기를 포함하고 있습니다.
DOM 조작을 하기위해서, 내장된 지시자(directives)를 사용하거나, 필요하다면 당신만의 지시자를 작성하십시오.
기능성 복재에 대한 내용을 아래에서 확인하십시오.
Stop trying to use jQuery to modify the DOM in controllers. Really.
That includes adding elements, removing elements, retrieving their contents, showing and hiding them.
Use built-in directives, or write your own where necessary, to do your DOM manipulation.
See below about duplicating functionality.

jQuery사용 습관을 버리는데 힘겨워하고 있다면, 당신의 앱(app)에서 jQuery를 없애 버리는 것을 고려해보십시오.
정말로, Angular는 jQuery가 언제 어디서나 필요 없게 하는 $http 서비스와 강력한 지시자를 가지고 있습니다.
Angular의 배포판 jQLite는 Angular 지시자 작성에, 특히 이벤트 바인딩에 아주 보편적으로 사용할 수 있는 작은 기능들이 있습니다.
If you're struggling to break the habit, consider removing jQuery from your app.
Really. Angular has the $http service and powerful directives that make it almost always unnecessary.
Angular's bundled jQLite has a handful of the features most commonly used in writing Angular directives, especially binding to events.

### 이미 존재하는 기능성 복재하기
### Trying to duplicate functionality that already exists

특정 기능성이 필요한 앱(app)이 당신게 처음이 아니라는게 좋은 기회입니다.
오래된 습관에서 벗어나, 특정적으로 재 수행되는 몇몇 Angular가 존재합니다.
There's a good chance that your app isn't the first to require certain functionality.
There are a few pieces of Angular that are particularly likely to be reimplemented out of old habits.

**ng-repeat**
**ng-repeat**

`ng-repeat`는 이럴 때 좋습니다.
사람들은 서버에서부터 받아올 때 몇몇의 컨테이너(container)에 더 많은 엘리먼트(element)를 추가하기 위해서 jQuery(위 참조)를 사용하려 합니다.
아닙니다. 그러지 마세요.
이것이 `ng-repeat`이 필요한 이유입니다.
`ng-repeat` gets this a lot.
People try to use jQuery (see above) to add more elements to some container as they're fetched from the server.
No, bad dog.
This is what `ng-repeat` is for, and it does its job very well.
Store the data from the server in an array on your `$scope`, and bind it to the DOM with `ng-repeat`.

**ng-show**

`ng-show` gets this frequently too.
Conditionally showing and hiding things using jQuery is a common pattern in other apps, but Angular has a better way.
`ng-show` (and `ng-hide`) conditionally show and hide elements based on boolean expressions.
Describe the conditions for showing and hiding an element in terms of `$scope` variables:

    <div ng-show="!loggedIn">Click <a href="#/login">here</a> to log in</div>

Note also the counterpart `ng-hide` and similar `ng-disabled`.
Note especially the powerful `ng-switch` that should be used instead of several mutually exclusive `ng-show`s.

**ng-class**

`ng-class` is the last of the big three.
Conditionally applying classes to elements is another thing commonly done manually using jQuery.
Angular, of course, has a better way.
You can give `ng-class` a whitespace-separated set of class names, and then it's identical to ordinary `class`.
That's not very exciting, so there's a second syntax:

    <div ng-class="{ errorClass: isError, warningClass: isWarning, okClass: !isError && !isWarning }">...</div>

Where you give `ng-class` an object, whose keys are CSS class names and whose values are conditional expressions using `$scope` variables.
The element will then have all the classes whose conditions are truthy, and none of those whose conditions are falsy.

Note also the handy `ng-class-even` and `ng-class-odd`, and the related though somewhat different `ng-style`.


### `$watch` and `$apply`

Angular's two-way data binding is the root of all awesome in Angular.
However, it's not magic, and there are some situations where you need to give it a nudge in the right direction.

When you bind a value to an element in Angular using `ng-model`, `ng-repeat`, etc., Angular creates a `$watch` on that value.
Then whenever a value on a scope changes, all `$watch`es observing that element are executed, and everything updates.

Sometimes, usually when you're writing a custom directive, you will have to define your own `$watch` on a scope value to make the directive react to changes.

On the flip side, sometimes you change a scope value in some code but the app doesn't react to it.
Angular checks for scope variable changes after pieces of your code have finished running; for example, when `ng-click` calls a function on your scope, Angular will check for changes and react.
However, some code is outside of Angular and you'll have to call `scope.$apply()` yourself to trigger the update.
This is most commonly seen in event handlers in custom directives.

### Combining `ng-repeat` with other directives

`ng-repeat` is extremely useful, one of the most powerful directives in Angular.
However the transformation it applies to the DOM is substantial.
Therefore applying other directives (such as `ng-show`, `ng-controller` and others) to the same element as `ng-repeat` generally leads to problems.

If you want to apply a directive to the whole repeat, wrap the repeat in a parent element and put it there.
If you want to apply a directive to each inner piece of the repeat, put it on a child of the element with `ng-repeat`.

### `$rootScope` exists, but it can be used for evil

Scopes in Angular form a hierarchy, prototypically inheriting from a root scope at the top of the tree.
Usually this can be ignored, since most views have a controller, and therefore a scope, of their own.

Occasionally there are pieces of data that you want to make global to the whole app.
For these, you can inject `$rootScope` and set values on it like any other scope.
Since the scopes inherit from the root scope, these values will be available to the expressions attached to directives like `ng-show` just like values on your local `$scope`.

Of course, global state sucks and you should use `$rootScope` sparingly, like you would (hopefully) use with global variables in any language.
In particular, don't use it for code, only data.
If you're tempted to put a function on `$rootScope`, it's almost always better to put it in a service that can be injected where it's needed, and more easily tested.

Conversely, don't create a service whose only purpose in life is to store and return bits of data.
